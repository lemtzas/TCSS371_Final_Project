Write a program that loads two numbers from a memory location and adds
them together, stores them in a third memory location.
At the end of this program you should be able to see the answer in the
destination register as well as the memory location. 

PC:
1	AND R1, R1, #0  ;initialize R1
2	AND R2, R2, R1  ;initialize R2
3	AND R3, R3, #0  ;initialize R3
4	AND R4, R4, #0  ;initialize R4
5	ADD R1, R1, #6  ;set R1 to 6
6	ADD R2, R2, #2  ;set R2 to 2
7	ADD R4, R4, #11 ;set R4 to 11
8	ST  R1, #11     ;set mem addr 20 to #6 (PC=9, +11=20)
9	STR R2, R4, #10 ;set mem addr 21 to #2 (R4=11, +10=21)
10	LD  R1, #9      ;load value from mem addr 20 into R1
11	LEA R4, #9      ;load #21 into R4
12	LDR R2, R4, #0  ;load value from mem addr 21 into R2
13	ADD R3, R1, R2  ;add R1 and R2 and place result in R3
14  ST  R3, #7      ;store value from R3 in mem addr 22
15  HALT            ;end the program

1	0101 0010 0110 0000		0x5260
2	0101 0100 1000 0001		0x5481
3	0101 0110 1110 0000		0x56E0
4	0101 1001 0010 0000		0x5920
5	0001 0010 0110 0110		0x1266
6	0001 0100 1010 0010		0x14A2
7	0001 1001 0010 1011		0x192B
8	0011 0010 0000 1011		0x320B
9	0111 0101 0000 1010		0x750A
10	0010 0010 0000 1001		0x2209
11	1110 1000 0000 1001		0xE809
12	0110 0101 0000 0000		0x6500
13	0001 0110 0100 0010		0x1642
14	0011 0110 0000 0111		0x3607
15	1000 0000 0000 0000		0x8000


Subtract a positive value (as stored in memory) from a positive value
(also in memory) and put the result back in another memory location.
Branch to another location if the result was negative where you will
store the contents of the source register 1 to a specific location in
memory. Otherwise store the contents of source register 2 in that
location. From either of these jump (if necessary) to the HALT
instruction. 

PC:
1	AND R1, R1, #0  ;initialize R1
2	AND R2, R2, R1  ;initialize R2	
3	ADD R1, R1, #6  ;set R1 to 6
4	ADD R2, R2, #2  ;set R2 to 2	
5	ST  R1, #24     ;set mem addr 30 to #6 (PC=6, +24=30)
6	ST  R2, #24     ;set mem addr 31 to #2 (PC=7, +24=31)
7	LD  R1, #23     ;load value from mem addr 31 into R1
8	LD  R2, #21     ;load value from mem addr 30 into R2
9	SUB R3, R1, R2  ;subtract R2 from R1 and store in R3 (switch for other branch)
10	ST  R3, #21     ;set mem addr 32 to the value stored in R3
11  AND R3, R3, #0  ;initialize R3
12  LEA R3, #20     ;load #33 into R3
13	BRn #4          ;load #19 into the PC if condition negative
14	STR R2, R3, #0  ;set mem addr 33 to the value stored in R2
15	AND R4, R4, #0  ;initialize R4
16	ADD R4, R4, #10 ;set R4 to 10
17	ADD R4, R4, R4  ;double the value in R4
18	JMP R4          ;jump to 20 (load 20 into the PC)
19	STR R1, R3, #0  ;set mem addr 33 to the value stored in R2
20	HALT

1	0101 0010 0110 0000		0x5260
2	0101 0100 1000 0001		0x5481
3	0001 0010 0110 0110		0x1266
4	0001 0100 1010 0010		0x14A2
5	0011 0010 0001 1000		0x3218
6	0011 0100 0001 1000		0x3418
7	0010 0010 0001 0111		0x2217
8	0010 0100 0001 0101		0x2415
9	1101 0110 0100 0010		0xD642	or	1101 0110 1000 0001		0xD681
10	0011 0110 0001 0101		0x3615
11	0101 0110 1110 0000		0x56E0
12	1110 0110 0001 0100		0xE614
13	0000 0001 0000 0100		0x0104
14	0111 0100 1100 0000		0x74C0
15	0101 1001 0010 0000		0x5920
16	0001 1001 0010 0110		0x1926
17	0001 1001 0000 0100		0x1904
18	1100 0001 0000 0000		0xC100
19	0111 0010 1100 0000		0x72C0
20	1000 0000 0000 0000		0x8000



Add two positive numbers that will force overflow (say 0x7FFF + 0x0005)
and put the result in a memory location. Then branch on overflow to a
part of the program that stores the source register 1 to a specified
location and goto HALT. Otherwise store source register 2 to that
location then goto HALT. Try this same program but using a smaller
number such as 0x6FFF to make sure the correct branch is taken. 

PC:
1	
2	
3	
4	
5	
6	

Load a positive value into a register from memory and NOT it using a
different destination register. Then branch on negative to a part of
the program where you store the contents of the destination register
to a memory location. After storing the negative value (say at a
location labeled NEGVAL) do an absolute branch back to the position
in the program immediately after the first branch (it needs a label).
Do the exact opposite operation; NOT the original destination register
and store it back in the original load register (e.g. say R2 was the
original load register and your first NOT used R1 as destination, then
the second time you would NOT R1 and store it back in R2). Branch on
positive, this time, to a point in the program where you store a
positive value, say at POSVAL. Then halt the program. Modify the value
in memory so that it is negative and then since the branch is not taken
(shouldn't be!) store the original load register to the same memory
location. 

PC:
1	
2	
3	
4	
5	
6	









